---
phase: 06-playbooks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/playbook-service.ts
  - src/app/api/playbooks/route.ts
  - src/app/api/playbooks/[playbookId]/route.ts
  - src/app/api/playbooks/[playbookId]/status/route.ts
  - src/app/api/playbooks/[playbookId]/sections/[sectionId]/route.ts
  - src/app/api/playbooks/[playbookId]/sections/[sectionId]/regenerate/route.ts
  - src/app/api/districts/[districtId]/playbooks/route.ts
autonomous: true

must_haves:
  truths:
    - "Playbook service can generate a playbook with sections from district + product data"
    - "Playbook service can retrieve playbooks filtered by fit category"
    - "Playbook service can update individual section content (edit)"
    - "Playbook service can regenerate individual sections"
    - "Playbook service can delete playbooks"
    - "Playbook service can return generation status with per-section status"
    - "All operations scoped to authenticated user"
  artifacts:
    - path: "src/services/playbook-service.ts"
      provides: "All playbook CRUD + generation logic"
      exports: ["generatePlaybook", "getPlaybook", "getPlaybooks", "getPlaybookStatus", "getExistingPlaybooks", "updatePlaybookSection", "regenerateSection", "deletePlaybook"]
    - path: "src/app/api/playbooks/route.ts"
      provides: "GET (list) and POST (generate) endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/playbooks/[playbookId]/route.ts"
      provides: "GET (detail) and DELETE endpoints"
      exports: ["GET", "DELETE"]
    - path: "src/app/api/playbooks/[playbookId]/status/route.ts"
      provides: "GET status endpoint for polling generation progress"
      exports: ["GET"]
    - path: "src/app/api/playbooks/[playbookId]/sections/[sectionId]/route.ts"
      provides: "GET (section detail) and PATCH (edit section) endpoints"
      exports: ["GET", "PATCH"]
    - path: "src/app/api/playbooks/[playbookId]/sections/[sectionId]/regenerate/route.ts"
      provides: "POST regenerate section endpoint"
      exports: ["POST"]
    - path: "src/app/api/districts/[districtId]/playbooks/route.ts"
      provides: "GET existing playbooks for a district"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/playbooks/route.ts"
      to: "src/services/playbook-service.ts"
      via: "import * as playbookService"
      pattern: "playbookService\\.(generatePlaybook|getPlaybooks)"
    - from: "src/services/playbook-service.ts"
      to: "prisma.playbook"
      via: "Prisma client queries"
      pattern: "prisma\\.(playbook|playbookSection)\\."
    - from: "src/services/playbook-service.ts"
      to: "src/services/district-service.ts"
      via: "getDistrict + getDistrictFitAssessment for generation"
      pattern: "districtService\\.getDistrict|districtService\\.getDistrictFitAssessment"
---

<objective>
Implement the complete playbook service layer and all API routes for playbook generation, retrieval, editing, regeneration, and deletion.

Purpose: Provides the data layer and API contract that the playbook UI (Plans 02 and 03) will consume. The service generates playbooks with 6 section types using district and product data, with a mock AI generator that produces realistic content from templates (ready for real AI swap later per three-layer architecture).

Output: playbook-service.ts with 8 exported functions, 7 API route files covering all PLAY-01 through PLAY-08 data operations.
</objective>

<execution_context>
@/Users/dorenberge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dorenberge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/types/playbook.ts
@src/services/types/common.ts
@src/services/interfaces/playbook-service.ts
@src/services/product-service.ts
@src/services/district-service.ts
@src/lib/auth-utils.ts
@src/app/api/products/route.ts
@src/app/api/products/[productId]/route.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Playbook service layer implementation</name>
  <files>src/services/playbook-service.ts</files>
  <action>
Create `src/services/playbook-service.ts` implementing all 8 methods from IPlaybookService interface. Follow the same pattern as product-service.ts (direct Prisma queries, error codes, tenant/user scoping).

**Functions to implement:**

1. **generatePlaybook(userId, districtId, productIds)** - Creates a Playbook record with overallStatus 'generating', creates 6 PlaybookSection records (one per section type), then runs mock generation. The 6 section types are:
   - `key_themes` (label: "Key Themes", source: "synthesis") - District challenges + product alignment summary
   - `product_fit` (label: "Product Fit Analysis", source: "synthesis") - Why products match this district
   - `objections` (label: "Anticipated Objections", source: "synthesis") - Common pushback and responses
   - `stakeholders` (label: "Key Stakeholders", source: "constrained") - Who to approach and how
   - `district_data` (label: "District Data Summary", source: "verbatim") - Key metrics snapshot
   - `fit_assessment` (label: "Fit Assessment", source: "hybrid") - Overall fit rationale

   For generation: Use `getDistrict(districtId)` from district-service to get district data. Use `prisma.product.findMany` to get products by IDs. Use `getDistrictFitAssessment(districtId, productIds)` for fit data. Store fitCategory and fitRationale from assessment on Playbook record. Use denormalized districtName, productNames, productIds on the Playbook record.

   **Mock AI generation:** Create a helper function `generateSectionContent(sectionType, district, products, fitAssessment)` that returns template-based content using real district/product data. Example for key_themes: include district name, enrollment, proficiency percentages, product names. Each section should be 3-5 paragraphs of realistic sales intelligence content. After creating the playbook record and section records (all with status 'pending'), iterate sections sequentially: update status to 'generating', call the mock generator, update status to 'complete' with content. Finally update playbook overallStatus to 'complete'. Wrap generation in try/catch - if any section fails, set that section to 'error' with errorMessage, continue others, set overallStatus to 'partial' if some failed, 'failed' if all failed.

   Return `{ playbookId }` immediately BEFORE running generation. Use a pattern where generation runs in a "fire and forget" async block (call the generation function but don't await it from the API perspective). This supports the async generation design from PROJECT.md.

2. **getPlaybookStatus(userId, playbookId)** - Query playbook with sections, verify userId matches. Return PlaybookStatusResponse with overallStatus and per-section status. Error PLAYBOOK_NOT_FOUND if not found or wrong user.

3. **getPlaybook(userId, playbookId)** - Full playbook with all sections. Verify userId. Map Prisma records to Playbook type. Include FitAssessment from fitCategory/fitRationale fields.

4. **getPlaybooks(userId, filters?)** - List all user's playbooks. Apply fitCategory filter if provided. Apply sortBy/sortOrder (default: generatedAt desc). Map to PlaybookSummary[] with hasEditedSections (check if any section isEdited) and sectionStatuses.

5. **getExistingPlaybooks(userId, districtId)** - Find playbooks for this user + district combo. Return PlaybookSummary[].

6. **updatePlaybookSection(userId, playbookId, sectionId, content)** - Find section, verify playbook ownership via userId, update content, set isEdited=true, lastEditedAt=now. Return updated PlaybookSection.

7. **regenerateSection(userId, playbookId, sectionId)** - Verify ownership, check section exists and retryable=true. Set status to 'generating', clear errorMessage. Fire-and-forget: re-run mock generation for that section type (need to load district/product data from playbook record). Return `{ status: 'generating' }`.

8. **deletePlaybook(userId, playbookId)** - Verify ownership. Delete all sections first (cascade), then delete playbook. Hard delete (no soft delete flag on playbook model - use Prisma cascading delete via deleteMany on sections then delete on playbook).

**Error patterns (match existing codebase):**
- `PLAYBOOK_NOT_FOUND` when playbook missing or wrong user
- `SECTION_NOT_FOUND` when section missing
- `DISTRICT_NOT_FOUND` when generating for invalid district
- `PRODUCT_NOT_FOUND` when no valid products in generation request
- All functions take userId as first parameter (per Phase 4 pattern)
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit --pretty 2>&1 | head -50`</verify>
  <done>playbook-service.ts exports 8 functions matching IPlaybookService interface methods. Each function uses Prisma queries scoped to userId, returns correct types, and throws coded errors.</done>
</task>

<task type="auto">
  <name>Task 2: Playbook API routes</name>
  <files>
    src/app/api/playbooks/route.ts
    src/app/api/playbooks/[playbookId]/route.ts
    src/app/api/playbooks/[playbookId]/status/route.ts
    src/app/api/playbooks/[playbookId]/sections/[sectionId]/route.ts
    src/app/api/playbooks/[playbookId]/sections/[sectionId]/regenerate/route.ts
    src/app/api/districts/[districtId]/playbooks/route.ts
  </files>
  <action>
Create 6 API route files following the exact pattern from `src/app/api/products/route.ts` and `src/app/api/products/[productId]/route.ts`: getCurrentUser() at boundary, pass user.id to service, map error codes to HTTP status.

**Route 1: `src/app/api/playbooks/route.ts`**
- `GET` - List playbooks. Parse query params: fitCategory (optional), sortBy (optional, default 'generatedAt'), sortOrder (optional, default 'desc'). Call `playbookService.getPlaybooks(user.id, filters)`. Return `{ playbooks }`.
- `POST` - Generate playbook. Parse body as `{ districtId, productIds }`. Call `playbookService.generatePlaybook(user.id, body.districtId, body.productIds)`. Return 202 (Accepted) with `{ playbookId }`.

**Route 2: `src/app/api/playbooks/[playbookId]/route.ts`**
- `GET` - Get playbook detail. Extract playbookId from params (await params pattern). Call `playbookService.getPlaybook(user.id, playbookId)`. Return playbook.
- `DELETE` - Delete playbook. Call `playbookService.deletePlaybook(user.id, playbookId)`. Return 204.

**Route 3: `src/app/api/playbooks/[playbookId]/status/route.ts`**
- `GET` - Get generation status. Call `playbookService.getPlaybookStatus(user.id, playbookId)`. Return status response.

**Route 4: `src/app/api/playbooks/[playbookId]/sections/[sectionId]/route.ts`**
- `GET` - Get section detail. Extract both playbookId and sectionId from params. Call service method (add getPlaybookSection to service if needed, or inline: get playbook, find section).
- `PATCH` - Edit section content. Parse body `{ content }`. Call `playbookService.updatePlaybookSection(user.id, playbookId, sectionId, body.content)`. Return updated section.

**Route 5: `src/app/api/playbooks/[playbookId]/sections/[sectionId]/regenerate/route.ts`**
- `POST` - Regenerate section. Call `playbookService.regenerateSection(user.id, playbookId, sectionId)`. Return 202 with `{ status: 'generating' }`.

**Route 6: `src/app/api/districts/[districtId]/playbooks/route.ts`**
- `GET` - Get existing playbooks for district. Call `playbookService.getExistingPlaybooks(user.id, districtId)`. Return `{ playbooks }`.

**Error handling for ALL routes (consistent pattern):**
- UNAUTHENTICATED/USER_NOT_FOUND → 401
- PLAYBOOK_NOT_FOUND → 404
- SECTION_NOT_FOUND → 404
- DISTRICT_NOT_FOUND → 404
- PRODUCT_NOT_FOUND → 404
- Unexpected errors → 500

**Important:** Use `params: Promise<{ playbookId: string }>` pattern for dynamic route params (Next.js 15 async params pattern used throughout codebase). For nested params like sections, use `params: Promise<{ playbookId: string; sectionId: string }>`.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit --pretty 2>&1 | head -50`</verify>
  <done>6 API route files created. POST /api/playbooks returns 202 for generation. GET/DELETE on playbook detail. GET for status polling. GET/PATCH for section detail/edit. POST for section regeneration. GET for district-specific playbooks. All routes authenticate via getCurrentUser and pass userId to service.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. playbook-service.ts has 8 exported async functions
3. API routes follow same pattern as product routes (getCurrentUser → service call → error mapping)
4. POST /api/playbooks returns 202 (async generation pattern)
5. All routes use await params for dynamic segments
</verification>

<success_criteria>
- Playbook service layer implements all IPlaybookService methods with Prisma queries
- Mock AI generator produces district-specific content using real data (not lorem ipsum)
- 6 API route files provide complete REST interface for playbook operations
- Fire-and-forget async generation pattern enables polling from UI
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06-playbooks/06-01-SUMMARY.md`
</output>
