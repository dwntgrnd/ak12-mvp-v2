---
phase: 02-auth-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/prisma.ts
  - .env
  - .env.example
  - .gitignore
autonomous: true
user_setup:
  - service: postgresql
    why: "Database for all application entities"
    env_vars:
      - name: DATABASE_URL
        source: "Local PostgreSQL or cloud provider (e.g., Neon, Supabase). Format: postgresql://user:password@host:port/dbname"
    dashboard_config: []

must_haves:
  truths:
    - "Prisma schema defines models for all application entities"
    - "Prisma client can be imported and used in server-side code"
    - "Database migrations run successfully against PostgreSQL"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Complete data model for all entities"
      contains: "model District"
    - path: "src/lib/prisma.ts"
      provides: "Singleton Prisma client for server-side use"
      exports: ["prisma"]
    - path: ".env.example"
      provides: "Template for required environment variables"
      contains: "DATABASE_URL"
  key_links:
    - from: "src/lib/prisma.ts"
      to: "@prisma/client"
      via: "PrismaClient import"
      pattern: "new PrismaClient"
    - from: "prisma/schema.prisma"
      to: "postgresql"
      via: "datasource db"
      pattern: "provider.*postgresql"
---

<objective>
Set up Prisma ORM with PostgreSQL and define the complete database schema for all AlchemyK12 entities: tenants, users, products, districts, playbooks, saved/excluded districts, and product assets.

Purpose: Establishes the data persistence layer that all future phases depend on. Every feature vertical (discovery, management, solutions, playbooks) needs these models.
Output: Prisma schema with all models, singleton client, database migrations applied.
</objective>

<execution_context>
@/Users/dorenberge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dorenberge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/types/common.ts
@src/services/types/auth.ts
@src/services/types/tenant.ts
@src/services/types/user.ts
@src/services/types/product.ts
@src/services/types/district.ts
@src/services/types/playbook.ts
@src/services/types/controlled-vocabulary.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Prisma and create complete database schema</name>
  <files>
    prisma/schema.prisma
    .env
    .env.example
    .gitignore
    package.json
  </files>
  <action>
Install Prisma: `npm install prisma @prisma/client && npx prisma init`

This creates prisma/schema.prisma and .env with DATABASE_URL placeholder.

Update .gitignore to include `.env` (but NOT .env.example).

Create .env.example with:
```
DATABASE_URL="postgresql://user:password@localhost:5432/alchemyk12?schema=public"
```

Define the complete Prisma schema in prisma/schema.prisma. Use PostgreSQL as the datasource provider. Use `uuid` for all primary keys via `@default(uuid())`. Include `createdAt` and `updatedAt` on all models.

**Models to define (map from existing TypeScript types in src/services/types/):**

1. **Tenant** - Maps to TenantSummary type
   - id (String, uuid), organizationName (String, unique), status (String, default "active"), createdAt, updatedAt

2. **User** - Maps to TenantUser + UserProfile types
   - id (String, uuid), clerkId (String, unique -- links to Clerk external auth), tenantId (FK to Tenant), email (String, unique), displayName (String), role (String -- "super-admin" | "publisher-admin" | "publisher-rep"), status (String, default "active" -- "pending" | "active" | "deactivated"), invitedAt (DateTime), lastActiveAt (DateTime, optional), createdAt, updatedAt
   - Relation: belongs to Tenant

3. **Product** - Maps to Product type
   - id (String, uuid), tenantId (FK to Tenant), name (String), description (String), gradeRange (String -- from GRADE_RANGES), subjectArea (String -- from SUBJECT_AREAS), keyFeatures (String[] -- Prisma array), targetChallenges (String[]), competitiveDifferentiators (String[]), approvedMessaging (String[]), isDeleted (Boolean, default false -- for soft delete), createdAt, updatedAt
   - Relation: belongs to Tenant, has many ProductAsset

4. **ProductAsset** - Maps to ProductAsset type
   - id (String, uuid), productId (FK to Product), fileName (String), fileType (String -- MIME), fileSize (Int), url (String), uploadedAt (DateTime, default now), createdAt, updatedAt
   - Relation: belongs to Product

5. **District** - Maps to DistrictProfile type
   - id (String, uuid), name (String), location (String), county (String), enrollment (Int), demographics (Json -- JSONB), proficiency (Json -- JSONB), funding (Json -- JSONB), additionalData (Json -- JSONB, optional), createdAt, updatedAt
   - Add unique constraint on name + county combination
   - Per PROJECT.md key decision: "District data stored as JSONB" for flexible schema

6. **SavedDistrict** - Maps to SavedDistrict type
   - id (String, uuid), userId (FK to User), districtId (FK to District), savedAt (DateTime, default now), createdAt, updatedAt
   - Unique constraint on [userId, districtId] -- can't save same district twice
   - Relations: belongs to User, belongs to District

7. **ExcludedDistrict** - Maps to ExcludedDistrict type
   - id (String, uuid), userId (FK to User), districtId (FK to District), category (String -- from EXCLUSION_CATEGORIES), note (String, optional), excludedAt (DateTime, default now), createdAt, updatedAt
   - Unique constraint on [userId, districtId]
   - Relations: belongs to User, belongs to District

8. **Playbook** - Maps to Playbook type
   - id (String, uuid), userId (FK to User), districtId (FK to District), districtName (String -- denormalized), productIds (String[]), productNames (String[] -- denormalized), fitCategory (String), fitRationale (String), overallStatus (String, default "generating"), generatedAt (DateTime, default now), createdAt, updatedAt
   - Relations: belongs to User, belongs to District, has many PlaybookSection

9. **PlaybookSection** - Maps to PlaybookSection type
   - id (String, uuid), playbookId (FK to Playbook), sectionType (String), sectionLabel (String), contentSource (String), status (String, default "pending"), content (String, optional), isEdited (Boolean, default false), lastEditedAt (DateTime, optional), errorMessage (String, optional), retryable (Boolean, default true), createdAt, updatedAt
   - Relation: belongs to Playbook

Use `@@map` for snake_case table names (e.g., `@@map("tenants")`). Use `@map` for snake_case column names (e.g., `organizationName @map("organization_name")`). This follows Prisma best practice: camelCase in TypeScript, snake_case in PostgreSQL.

DO NOT add enum types in Prisma -- the controlled vocabulary is already defined as const arrays in TypeScript (src/services/types/controlled-vocabulary.ts). Using String fields with application-level validation keeps the single source of truth in TypeScript per the Phase 1 decision.
  </action>
  <verify>
Run `npx prisma validate` -- should exit 0 with "The schema is valid."
Run `npx prisma generate` -- should generate Prisma client without errors.
Verify .env.example exists with DATABASE_URL template.
Verify .gitignore contains .env entry.
  </verify>
  <done>
prisma/schema.prisma defines 9 models (Tenant, User, Product, ProductAsset, District, SavedDistrict, ExcludedDistrict, Playbook, PlaybookSection) with all fields, relations, and constraints. Prisma client generates successfully. .env.example documents required DATABASE_URL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Prisma singleton client and run initial migration</name>
  <files>
    src/lib/prisma.ts
  </files>
  <action>
Create src/lib/prisma.ts with the standard Next.js Prisma singleton pattern to prevent multiple client instances during hot reload:

```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

This pattern:
- Creates one PrismaClient instance per process
- Attaches to globalThis in development to survive Next.js hot reloads
- Creates fresh instance in production (single instance per serverless function)

Then attempt to run the initial migration. If DATABASE_URL is configured:
```bash
npx prisma migrate dev --name init
```

If DATABASE_URL is not available (user hasn't set up PostgreSQL yet), this is expected. The migration command will be documented for the user to run after setting up their database. The plan still succeeds -- schema validation and client generation are sufficient proof of correctness.
  </action>
  <verify>
Run `npx tsc --noEmit` -- TypeScript compilation succeeds with the new Prisma client import.
Verify src/lib/prisma.ts exists and exports `prisma`.
If DATABASE_URL is set, verify `npx prisma migrate dev --name init` succeeds.
  </verify>
  <done>
src/lib/prisma.ts exports a singleton Prisma client. TypeScript compiles without errors. If database is available, initial migration creates all 9 tables with proper relations and constraints.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma validate` exits 0
2. `npx prisma generate` exits 0
3. `npx tsc --noEmit` exits 0
4. prisma/schema.prisma contains all 9 models
5. src/lib/prisma.ts exports singleton client
6. .env.example documents DATABASE_URL
</verification>

<success_criteria>
- Prisma schema defines 9 models matching all TypeScript service types
- All relations (Tenant->User, User->SavedDistrict, etc.) are properly defined
- JSONB fields used for demographics, proficiency, funding (per PROJECT.md decision)
- Prisma client generates and TypeScript compiles
- Database migration is ready to run (or already run if DB available)
</success_criteria>

<output>
After completion, create `.planning/phases/02-auth-data-layer/02-01-SUMMARY.md`
</output>
