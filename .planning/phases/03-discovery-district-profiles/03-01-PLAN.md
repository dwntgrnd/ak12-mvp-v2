---
phase: 03-discovery-district-profiles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/district-service.ts
  - src/app/api/districts/route.ts
  - src/app/api/districts/filters/route.ts
  - src/app/api/districts/[districtId]/route.ts
  - src/app/api/districts/[districtId]/fit/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/districts returns paginated district results with search and filter support"
    - "GET /api/districts/filters returns dynamic filter facets derived from actual district data"
    - "GET /api/districts/[districtId] returns full district profile with demographics, proficiency, and funding"
    - "GET /api/districts/[districtId]/fit returns fit assessment for given product IDs"
  artifacts:
    - path: "src/services/district-service.ts"
      provides: "Server-side district service implementing search, filter, detail, and fit assessment"
      exports: ["searchDistricts", "getDistrict", "getAvailableFilters", "getDistrictFitAssessment"]
    - path: "src/app/api/districts/route.ts"
      provides: "District search API endpoint"
      exports: ["GET"]
    - path: "src/app/api/districts/filters/route.ts"
      provides: "Filter facets API endpoint"
      exports: ["GET"]
    - path: "src/app/api/districts/[districtId]/route.ts"
      provides: "District detail API endpoint"
      exports: ["GET"]
    - path: "src/app/api/districts/[districtId]/fit/route.ts"
      provides: "Fit assessment API endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/services/district-service.ts"
      to: "prisma.district"
      via: "Prisma client queries"
      pattern: "prisma\\.district\\.(findMany|findUnique|count)"
    - from: "src/app/api/districts/route.ts"
      to: "src/services/district-service.ts"
      via: "direct import"
      pattern: "import.*district-service"
---

<objective>
Implement the district service layer and API routes for search, filtering, detail retrieval, and product-district fit assessment.

Purpose: Provides the data backend that Discovery Search UI (03-02) and District Profile Page (03-03) will consume. All four Phase 3 API endpoints must work correctly before any frontend can be built.

Output: 5 files - 1 service module + 4 API route handlers
</objective>

<execution_context>
@/Users/dorenberge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dorenberge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/services/types/district.ts
@src/services/types/common.ts
@src/services/interfaces/district-service.ts
@src/services/types/controlled-vocabulary.ts
@src/lib/prisma.ts
@prisma/schema.prisma
@prisma/seed.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement district service module</name>
  <files>src/services/district-service.ts</files>
  <action>
Create `src/services/district-service.ts` exporting four functions that query the database using the Prisma client from `src/lib/prisma.ts`. All functions are server-side only (no "use client").

**searchDistricts(request: DistrictSearchRequest): Promise<PaginatedResponse<DistrictSummary>>**
- Accept optional searchQuery, filters, page (default 1), pageSize (default 25), includeExcluded (default false)
- Search by name using Prisma `contains` (case-insensitive via `mode: 'insensitive'`)
- Apply filters from the `filters` Record:
  - `county` (string or string[]): Filter by county name(s) using `in` operator
  - `enrollmentMin` (number): Filter enrollment >= value
  - `enrollmentMax` (number): Filter enrollment <= value
- If `includeExcluded` is false, do NOT filter by exclusion status (we have no user context at the service level yet; exclusion filtering deferred to Phase 4 when user context is wired)
- Use `prisma.district.findMany()` with `skip` and `take` for pagination
- Use `prisma.district.count()` with same `where` clause for totalCount
- Map Prisma District to DistrictSummary: { districtId: id, name, location, enrollment }
- Return PaginatedResponse with items, totalCount, page, pageSize, totalPages (Math.ceil)

**getDistrict(districtId: string): Promise<DistrictProfile>**
- Use `prisma.district.findUnique({ where: { id: districtId } })`
- Throw an error with code "DISTRICT_NOT_FOUND" if null
- Map to DistrictProfile: { districtId: id, name, location, county, enrollment, demographics (cast Json to Record<string, number>), proficiency (cast Json to Record<string, number>), funding (cast Json to Record<string, number>), additionalData (cast Json to Record<string, unknown> or empty object) }
- Do NOT populate fitAssessment (that's a separate call)

**getAvailableFilters(): Promise<FilterFacet[]>**
- Query all districts to compute dynamic facets:
  - County facet: `SELECT county, COUNT(*) FROM districts GROUP BY county ORDER BY count DESC`. Return as FilterFacet { filterName: "county", filterLabel: "County", filterType: "multi-select", options: [{ value: county, label: county, count }] }
  - Enrollment range facet: `SELECT MIN(enrollment), MAX(enrollment) FROM districts`. Return as FilterFacet { filterName: "enrollment", filterLabel: "Enrollment", filterType: "range", range: { min, max, step: 1000 } }
- Use Prisma `groupBy` for county aggregation and `aggregate` for enrollment min/max

**getDistrictFitAssessment(districtId: string, productIds: string[]): Promise<FitAssessment>**
- Retrieve the district profile
- Retrieve products by IDs using `prisma.product.findMany({ where: { id: { in: productIds }, isDeleted: false } })`
- If no products found, throw error with code "PRODUCT_NOT_FOUND"
- Implement a simple heuristic fit assessment algorithm:
  - Score based on: enrollment size (larger = more opportunity), proficiency levels (lower = more need for intervention products, higher = good fit for enrichment), funding levels (higher per-pupil = more budget)
  - For MVP, use a straightforward scoring: compute average proficiency across Math/ELA/Science. If avg < 35 and product targets Intervention/SEL: "strong". If avg > 50 and product targets Assessment/STEM: "strong". Otherwise base on enrollment (>50K = "moderate", else "low")
  - Return FitAssessment { fitCategory, fitRationale } with a human-readable rationale string explaining why

Import types from `@/services/types/district` and `@/services/types/common`. Import prisma from `@/lib/prisma`.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation succeeds. Verify file exports all four functions by checking the file contents.
  </verify>
  <done>
district-service.ts exports searchDistricts, getDistrict, getAvailableFilters, and getDistrictFitAssessment functions. TypeScript compiles without errors. All functions use Prisma client for database queries and return typed responses matching the service interface.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create district API route handlers</name>
  <files>
src/app/api/districts/route.ts
src/app/api/districts/filters/route.ts
src/app/api/districts/[districtId]/route.ts
src/app/api/districts/[districtId]/fit/route.ts
  </files>
  <action>
Create four Next.js App Router API route handlers. All use `NextResponse.json()` for responses. All handle errors with try/catch returning appropriate HTTP status codes.

**GET /api/districts (src/app/api/districts/route.ts)**
- Parse query params from `request.nextUrl.searchParams`:
  - `q` (string, optional) -> searchQuery
  - `county` (string, comma-separated, optional) -> split into string[] for filters.county
  - `enrollmentMin` (number, optional) -> filters.enrollmentMin
  - `enrollmentMax` (number, optional) -> filters.enrollmentMax
  - `page` (number, default 1)
  - `pageSize` (number, default 25, max 100)
- Call `searchDistricts()` from district-service
- Return 200 with PaginatedResponse<DistrictSummary>
- On error: 500 with { error: message }

**GET /api/districts/filters (src/app/api/districts/filters/route.ts)**
- No query params needed
- Call `getAvailableFilters()` from district-service
- Return 200 with FilterFacet[]
- On error: 500 with { error: message }

**GET /api/districts/[districtId] (src/app/api/districts/[districtId]/route.ts)**
- Extract `districtId` from `params` (Next.js 15 async params pattern: `const { districtId } = await params`)
- Call `getDistrict(districtId)` from district-service
- Return 200 with DistrictProfile
- On DISTRICT_NOT_FOUND error: 404 with { error: "District not found" }
- On other errors: 500 with { error: message }

**GET /api/districts/[districtId]/fit (src/app/api/districts/[districtId]/fit/route.ts)**
- Extract `districtId` from `params` (async params pattern)
- Parse `productIds` from query params (comma-separated string)
- If no productIds provided, return 400 with { error: "productIds query parameter required" }
- Call `getDistrictFitAssessment(districtId, productIds)` from district-service
- Return 200 with FitAssessment
- On DISTRICT_NOT_FOUND: 404
- On PRODUCT_NOT_FOUND: 404 with { error: "No matching products found" }
- On other errors: 500

All routes import from `@/services/district-service`. Use the Next.js 15 route handler signature: `export async function GET(request: NextRequest, { params }: { params: Promise<{ districtId: string }> })` for dynamic routes, and `export async function GET(request: NextRequest)` for static routes.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation succeeds. Verify all four route files exist and each exports a GET function.
  </verify>
  <done>
Four API route handlers exist at the correct paths. Each exports a GET function. TypeScript compiles without errors. Routes parse query parameters correctly and delegate to district-service functions. Error handling returns appropriate HTTP status codes (400, 404, 500).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` exits 0 (TypeScript compilation passes)
2. `src/services/district-service.ts` exists and exports four named functions
3. All four API route files exist at correct paths under `src/app/api/districts/`
4. Each API route exports a GET function
5. No circular imports between service and API layers
</verification>

<success_criteria>
- District service module implements all four Phase 3 data operations (search, detail, filters, fit)
- API routes correctly parse query parameters and return typed JSON responses
- Error handling provides meaningful status codes and messages
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-discovery-district-profiles/03-01-SUMMARY.md`
</output>
