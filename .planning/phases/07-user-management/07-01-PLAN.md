---
phase: 07-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/user-service.ts
  - src/app/api/users/route.ts
  - src/app/api/users/invite/route.ts
  - src/app/api/users/[userId]/deactivate/route.ts
  - src/app/api/users/[userId]/reactivate/route.ts
autonomous: true

must_haves:
  truths:
    - "User service functions exist for invite, list, deactivate, reactivate"
    - "API routes enforce publisher-admin authorization on all endpoints"
    - "Invite creates a User record with status 'pending' and assigned role"
    - "Deactivate sets user status to 'deactivated' and prevents self-deactivation"
    - "Reactivate sets user status back to 'active' from 'deactivated'"
    - "All operations are tenant-scoped (admin can only manage users in their own tenant)"
  artifacts:
    - path: "src/services/user-service.ts"
      provides: "User management service functions"
      exports: ["inviteUser", "getUsers", "deactivateUser", "reactivateUser"]
    - path: "src/app/api/users/route.ts"
      provides: "GET /api/users - list users"
      exports: ["GET"]
    - path: "src/app/api/users/invite/route.ts"
      provides: "POST /api/users/invite - invite user"
      exports: ["POST"]
    - path: "src/app/api/users/[userId]/deactivate/route.ts"
      provides: "PATCH /api/users/[userId]/deactivate"
      exports: ["PATCH"]
    - path: "src/app/api/users/[userId]/reactivate/route.ts"
      provides: "PATCH /api/users/[userId]/reactivate"
      exports: ["PATCH"]
  key_links:
    - from: "src/app/api/users/invite/route.ts"
      to: "src/services/user-service.ts"
      via: "inviteUser function call"
      pattern: "userService\\.inviteUser|inviteUser\\("
    - from: "src/services/user-service.ts"
      to: "prisma.user"
      via: "Prisma create/update/findMany queries"
      pattern: "prisma\\.user\\.(create|update|findMany)"
    - from: "src/app/api/users/route.ts"
      to: "src/lib/auth-utils.ts"
      via: "getCurrentUser for auth resolution"
      pattern: "getCurrentUser\\(\\)"
---

<objective>
User management service layer and API routes for invite, list, deactivate, and reactivate operations.

Purpose: Backend foundation for admin user management. All 4 IUserService methods implemented as Prisma-backed service functions with tenant-scoped API routes enforcing publisher-admin authorization.
Output: User service module + 4 API endpoints ready for UI consumption.
</objective>

<execution_context>
@/Users/dorenberge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dorenberge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/services/types/user.ts
@src/services/types/common.ts
@src/services/interfaces/user-service.ts
@src/lib/auth-utils.ts
@src/lib/prisma.ts
@prisma/schema.prisma
@src/app/api/products/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user management service functions</name>
  <files>src/services/user-service.ts</files>
  <action>
Create src/services/user-service.ts implementing the 4 IUserService methods. Follow the established service pattern from product-service.ts and district-service.ts (tenantId-first parameter, Prisma queries, error codes).

Functions to implement:

1. **inviteUser(tenantId: string, adminUserId: string, request: InviteUserRequest): Promise<TenantUser>**
   - Validate email is not already in use within the tenant (check prisma.user.findFirst where email AND tenantId match)
   - If duplicate email found, throw error with code 'DUPLICATE_EMAIL'
   - Create new User record via prisma.user.create with:
     - email: request.email
     - displayName: request.displayName
     - role: request.role (must be 'publisher-admin' or 'publisher-rep')
     - tenantId: tenantId
     - status: 'pending'
     - clerkId: generate a placeholder string like `pending_${uuid()}` (real Clerk ID gets set when user accepts invite and signs up -- actual Clerk invitation flow is out of MVP scope)
     - invitedAt: new Date()
   - Return mapped TenantUser object

2. **getUsers(tenantId: string): Promise<TenantUser[]>**
   - Query prisma.user.findMany where tenantId matches, ordered by createdAt desc
   - Map each Prisma User to TenantUser type (userId=id, email, displayName, userRole=role as cast, status as cast, invitedAt=invitedAt.toISOString(), lastActiveAt=lastActiveAt?.toISOString())

3. **deactivateUser(tenantId: string, adminUserId: string, targetUserId: string): Promise<TenantUser>**
   - Find user by id AND tenantId (tenant scoping)
   - If not found, throw error with code 'USER_NOT_FOUND'
   - If targetUserId === adminUserId, throw error with code 'CANNOT_DEACTIVATE_SELF'
   - Check if target is the last active admin in tenant: count users where tenantId AND role='publisher-admin' AND status='active'. If count <= 1 and target is publisher-admin, throw error with code 'LAST_ADMIN'
   - Update user status to 'deactivated'
   - Return mapped TenantUser

4. **reactivateUser(tenantId: string, targetUserId: string): Promise<TenantUser>**
   - Find user by id AND tenantId
   - If not found, throw error with code 'USER_NOT_FOUND'
   - If user.status !== 'deactivated', throw error with code 'USER_NOT_DEACTIVATED'
   - Update user status to 'active'
   - Return mapped TenantUser

Create a private helper function `mapToTenantUser(user: PrismaUser): TenantUser` to avoid repetition in the mapping logic.

Use the error throwing pattern from district-service.ts: `const error: any = new Error(message); error.code = 'CODE'; throw error;`

Import types from '@/services/types/user' and '@/lib/prisma'.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero TypeScript errors. Verify file exports inviteUser, getUsers, deactivateUser, reactivateUser.</verify>
  <done>User service module exists at src/services/user-service.ts with 4 exported functions, all type-safe with proper error handling, tenant scoping, and Prisma queries.</done>
</task>

<task type="auto">
  <name>Task 2: Create user management API routes</name>
  <files>
    src/app/api/users/route.ts
    src/app/api/users/invite/route.ts
    src/app/api/users/[userId]/deactivate/route.ts
    src/app/api/users/[userId]/reactivate/route.ts
  </files>
  <action>
Create 4 API route files following the established pattern from src/app/api/products/route.ts (getCurrentUser at boundary, admin role check, error code to HTTP status mapping).

All routes enforce publisher-admin (or super-admin) authorization. Pattern:
```
const user = await getCurrentUser();
if (user.role !== 'publisher-admin' && user.role !== 'super-admin') {
  return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
}
```

1. **GET /api/users** (src/app/api/users/route.ts)
   - Call getCurrentUser(), check admin role
   - Call getUsers(user.tenantId)
   - Return { users } with status 200
   - Error mapping: UNAUTHENTICATED/USER_NOT_FOUND -> 401

2. **POST /api/users/invite** (src/app/api/users/invite/route.ts)
   - Call getCurrentUser(), check admin role
   - Parse body as InviteUserRequest
   - Validate required fields: email (string, non-empty), displayName (string, non-empty), role (must be 'publisher-admin' or 'publisher-rep')
   - Call inviteUser(user.tenantId, user.id, body)
   - Return created user with status 201
   - Error mapping: DUPLICATE_EMAIL -> 409, INVALID_EMAIL -> 400, UNAUTHENTICATED -> 401

3. **PATCH /api/users/[userId]/deactivate** (src/app/api/users/[userId]/deactivate/route.ts)
   - Extract userId from route params (Next.js 15 pattern: params is a Promise, await it)
   - Call getCurrentUser(), check admin role
   - Call deactivateUser(user.tenantId, user.id, userId)
   - Return updated user with status 200
   - Error mapping: USER_NOT_FOUND -> 404, CANNOT_DEACTIVATE_SELF -> 400, LAST_ADMIN -> 400

4. **PATCH /api/users/[userId]/reactivate** (src/app/api/users/[userId]/reactivate/route.ts)
   - Extract userId from route params (await params)
   - Call getCurrentUser(), check admin role
   - Call reactivateUser(user.tenantId, userId)
   - Return updated user with status 200
   - Error mapping: USER_NOT_FOUND -> 404, USER_NOT_DEACTIVATED -> 400

IMPORTANT: In Next.js 15 App Router, dynamic route params are accessed via `const { userId } = await params;` (params is a Promise). Follow this pattern consistently.

Import getCurrentUser from '@/lib/auth-utils' and service functions from '@/services/user-service'.
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero TypeScript errors. Verify all 4 route files exist with correct HTTP method exports.</verify>
  <done>4 API routes exist and compile: GET /api/users returns user list, POST /api/users/invite creates pending user, PATCH /api/users/[userId]/deactivate deactivates user, PATCH /api/users/[userId]/reactivate reactivates user. All routes enforce admin authorization and return appropriate HTTP status codes.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` exits 0 (all files compile)
2. src/services/user-service.ts exports 4 functions: inviteUser, getUsers, deactivateUser, reactivateUser
3. All 4 API route files exist with correct method exports (GET, POST, PATCH, PATCH)
4. Admin role check present in all 4 routes
5. Error codes mapped to correct HTTP statuses
</verification>

<success_criteria>
- User service layer implements all 4 IUserService methods with tenant scoping
- API routes enforce publisher-admin authorization
- Invite creates User with status 'pending' and placeholder clerkId
- Deactivate prevents self-deactivation and last-admin removal
- Reactivate only works on deactivated users
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-user-management/07-01-SUMMARY.md`
</output>
