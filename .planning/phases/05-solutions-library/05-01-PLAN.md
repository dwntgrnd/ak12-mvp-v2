---
phase: 05-solutions-library
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/product-service.ts
  - src/app/api/products/route.ts
  - src/app/api/products/[productId]/route.ts
  - src/app/api/products/[productId]/assets/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/products returns product list with optional grade range and subject area filters"
    - "GET /api/products/[productId] returns full product detail with assets"
    - "POST /api/products creates a new product (admin only)"
    - "PATCH /api/products/[productId] updates existing product (admin only)"
    - "DELETE /api/products/[productId] soft-deletes a product (admin only)"
    - "POST /api/products/[productId]/assets stores asset metadata for a product (admin only)"
  artifacts:
    - path: "src/services/product-service.ts"
      provides: "Product CRUD service functions"
      exports: ["getProducts", "getProduct", "createProduct", "updateProduct", "deleteProduct", "uploadProductAsset"]
    - path: "src/app/api/products/route.ts"
      provides: "Product list and create endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/products/[productId]/route.ts"
      provides: "Product detail, update, delete endpoints"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "src/app/api/products/[productId]/assets/route.ts"
      provides: "Product asset upload endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/products/route.ts"
      to: "src/services/product-service.ts"
      via: "import { getProducts, createProduct }"
      pattern: "getProducts|createProduct"
    - from: "src/app/api/products/[productId]/route.ts"
      to: "src/services/product-service.ts"
      via: "import { getProduct, updateProduct, deleteProduct }"
      pattern: "getProduct|updateProduct|deleteProduct"
    - from: "src/services/product-service.ts"
      to: "prisma.product"
      via: "Prisma client queries"
      pattern: "prisma\\.product\\.(findMany|findUnique|create|update)"
---

<objective>
Build the product service layer and API routes for the Solutions Library.

Purpose: Establish the backend for product catalog CRUD operations, enabling the UI to list, view, create, edit, soft-delete products, and manage product assets. All write operations are restricted to admin users.

Output: Product service functions and 4 API route files providing full product lifecycle management.
</objective>

<execution_context>
@/Users/dorenberge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dorenberge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/types/product.ts
@src/services/interfaces/product-service.ts
@src/services/types/controlled-vocabulary.ts
@src/services/district-service.ts
@src/lib/auth-utils.ts
@src/lib/prisma.ts
@prisma/schema.prisma
@src/app/api/districts/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create product service functions</name>
  <files>src/services/product-service.ts</files>
  <action>
Create `src/services/product-service.ts` implementing all 6 product operations following the established district-service.ts pattern.

**Functions to implement:**

1. `getProducts(tenantId: string, filters?: ProductFilters): Promise<ProductSummary[]>` - Query products table filtered by tenantId, exclude soft-deleted (isDeleted=false). Support optional filters: gradeRange (exact match), subjectArea (exact match), searchQuery (name contains, case-insensitive). Return ProductSummary[] with productId, name, description (first 150 chars), gradeRange, subjectArea, assetCount (count of related ProductAsset records). Order by name ascending.

2. `getProduct(tenantId: string, productId: string): Promise<Product>` - Find product by id AND tenantId, exclude soft-deleted. Include ProductAsset[] relations. Throw error with code 'PRODUCT_NOT_FOUND' if not found. Map Prisma result to Product type from product.ts (map id->productId, assets with id->assetId).

3. `createProduct(tenantId: string, data: CreateProductRequest): Promise<Product>` - Validate gradeRange is in GRADE_RANGES and subjectArea is in SUBJECT_AREAS from controlled-vocabulary.ts. Create product with tenantId. Return full Product with empty assets array. Throw error code 'VALIDATION_ERROR' if grade/subject invalid.

4. `updateProduct(tenantId: string, productId: string, data: UpdateProductRequest): Promise<Product>` - Find product by id AND tenantId (not soft-deleted). If not found, throw 'PRODUCT_NOT_FOUND'. Validate gradeRange/subjectArea if provided. Update only provided fields. Return updated Product with assets. Use Prisma update with include for assets.

5. `deleteProduct(tenantId: string, productId: string): Promise<void>` - Soft delete: set isDeleted=true. Find by id AND tenantId (not already deleted). Throw 'PRODUCT_NOT_FOUND' if not found. Use Prisma update (not delete).

6. `uploadProductAsset(tenantId: string, productId: string, assetData: { fileName: string; fileType: string; fileSize: number; url: string }): Promise<ProductAsset>` - Verify product exists (by id AND tenantId, not deleted). Create ProductAsset record linked to productId. Return mapped ProductAsset (id->assetId). For MVP, url is stored directly (no actual file upload to cloud storage - that comes later).

**Pattern notes:**
- Follow district-service.ts error pattern: `const error: any = new Error('message'); error.code = 'CODE'; throw error;`
- Import from `@/lib/prisma` for database access
- Import types from `@/services/types/product` and `@/services/types/controlled-vocabulary`
- All functions accept tenantId as first parameter (resolved at API boundary via getCurrentUser)
- All queries filter by tenantId for multi-tenant isolation
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero TypeScript errors. Verify file exists and exports all 6 functions.</verify>
  <done>Product service file exists with 6 exported functions. All functions accept tenantId for multi-tenant scoping. Soft-delete uses isDeleted flag. Validation checks controlled vocabulary. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create product API routes</name>
  <files>
    src/app/api/products/route.ts
    src/app/api/products/[productId]/route.ts
    src/app/api/products/[productId]/assets/route.ts
  </files>
  <action>
Create 3 API route files following the established pattern from district API routes.

**File 1: `src/app/api/products/route.ts`**

GET handler:
- Call getCurrentUser() to get user.tenantId
- Parse query params: gradeRange, subjectArea, q (searchQuery)
- Build ProductFilters object from params
- Call getProducts(tenantId, filters)
- Return JSON { products: ProductSummary[] }
- Catch errors: UNAUTHENTICATED/USER_NOT_FOUND -> 401, default -> 500

POST handler (admin only):
- Call getCurrentUser() to get user.tenantId and user.role
- Check role is 'publisher-admin' or 'super-admin', else return 403 { error: 'Forbidden' }
- Parse request body as CreateProductRequest
- Call createProduct(tenantId, data)
- Return 201 with created Product
- Catch errors: VALIDATION_ERROR -> 400, UNAUTHENTICATED/USER_NOT_FOUND -> 401, default -> 500

**File 2: `src/app/api/products/[productId]/route.ts`**

GET handler:
- Call getCurrentUser() to get user.tenantId
- Extract productId from params (await params pattern for Next.js 15)
- Call getProduct(tenantId, productId)
- Return JSON with Product
- Catch: PRODUCT_NOT_FOUND -> 404, UNAUTHENTICATED/USER_NOT_FOUND -> 401, default -> 500

PATCH handler (admin only):
- Call getCurrentUser(), check admin role (else 403)
- Parse body as UpdateProductRequest
- Call updateProduct(tenantId, productId, data)
- Return JSON with updated Product
- Catch: PRODUCT_NOT_FOUND -> 404, VALIDATION_ERROR -> 400, UNAUTHENTICATED/USER_NOT_FOUND -> 401, default -> 500

DELETE handler (admin only):
- Call getCurrentUser(), check admin role (else 403)
- Call deleteProduct(tenantId, productId)
- Return 204 (no content)
- Catch: PRODUCT_NOT_FOUND -> 404, UNAUTHENTICATED/USER_NOT_FOUND -> 401, default -> 500

**File 3: `src/app/api/products/[productId]/assets/route.ts`**

POST handler (admin only):
- Call getCurrentUser(), check admin role (else 403)
- Parse body as { fileName: string, fileType: string, fileSize: number, url: string }
- Call uploadProductAsset(tenantId, productId, body)
- Return 201 with ProductAsset
- Catch: PRODUCT_NOT_FOUND -> 404, UNAUTHENTICATED/USER_NOT_FOUND -> 401, default -> 500

**Pattern notes:**
- Use `import { getCurrentUser } from '@/lib/auth-utils'`
- Use `import { NextRequest, NextResponse } from 'next/server'`
- Use `import * as productService from '@/services/product-service'` or named imports
- For params in dynamic routes with Next.js 15: `{ params }: { params: Promise<{ productId: string }> }` and `const { productId } = await params;`
- Admin check helper: `if (user.role !== 'publisher-admin' && user.role !== 'super-admin')`
  </action>
  <verify>Run `npx tsc --noEmit` and confirm zero TypeScript errors. Verify all 3 route files exist with correct HTTP method exports.</verify>
  <done>Three API route files exist. GET /api/products returns filtered product list. GET/PATCH/DELETE /api/products/[productId] handle detail/update/delete. POST /api/products/[productId]/assets handles asset metadata. Write operations check admin role. All routes authenticate via getCurrentUser. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Product service exports 6 functions: getProducts, getProduct, createProduct, updateProduct, deleteProduct, uploadProductAsset
- API routes exist at all 3 paths with correct HTTP method exports
- All API routes call getCurrentUser() for authentication
- Write endpoints (POST, PATCH, DELETE) check admin role
- All queries filter by tenantId for multi-tenant isolation
</verification>

<success_criteria>
Product backend is complete: service layer with 6 functions and 4 API route files with full CRUD + asset upload. All operations tenant-scoped. Write operations admin-restricted. TypeScript compiles cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/05-solutions-library/05-01-SUMMARY.md`
</output>
