---
phase: 04-district-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/auth-utils.ts
  - src/services/district-service.ts
  - src/app/api/districts/saved/route.ts
  - src/app/api/districts/[districtId]/save/route.ts
  - src/app/api/districts/[districtId]/exclude/route.ts
  - src/app/api/districts/[districtId]/restore/route.ts
autonomous: true

must_haves:
  truths:
    - "API can resolve Clerk session to internal User ID for ownership-scoped queries"
    - "API can save a district for the authenticated user (POST returns SavedDistrict)"
    - "API can list all saved districts for the authenticated user"
    - "API can remove a saved district for the authenticated user"
    - "API can exclude a district with a categorized reason for the authenticated user"
    - "API can list all excluded districts for the authenticated user"
    - "API can restore an excluded district for the authenticated user"
  artifacts:
    - path: "src/lib/auth-utils.ts"
      provides: "getCurrentUser helper resolving Clerk auth to internal DB user"
      exports: ["getCurrentUser"]
    - path: "src/services/district-service.ts"
      provides: "Six new service functions for save/exclude/restore operations"
      exports: ["saveDistrict", "getSavedDistricts", "removeSavedDistrict", "excludeDistrict", "getExcludedDistricts", "restoreDistrict"]
    - path: "src/app/api/districts/saved/route.ts"
      provides: "GET endpoint returning user's saved districts list"
      exports: ["GET"]
    - path: "src/app/api/districts/[districtId]/save/route.ts"
      provides: "POST to save, DELETE to unsave a district"
      exports: ["POST", "DELETE"]
    - path: "src/app/api/districts/[districtId]/exclude/route.ts"
      provides: "POST to exclude a district with reason"
      exports: ["POST"]
    - path: "src/app/api/districts/[districtId]/restore/route.ts"
      provides: "POST to restore an excluded district"
      exports: ["POST"]
  key_links:
    - from: "src/lib/auth-utils.ts"
      to: "@clerk/nextjs/server"
      via: "auth() call to get Clerk userId, then Prisma lookup by clerkId"
      pattern: "auth\\(\\).*prisma\\.user\\.findUnique"
    - from: "src/services/district-service.ts"
      to: "prisma.savedDistrict"
      via: "Prisma CRUD operations on SavedDistrict model"
      pattern: "prisma\\.savedDistrict\\.(create|findMany|delete)"
    - from: "src/services/district-service.ts"
      to: "prisma.excludedDistrict"
      via: "Prisma CRUD operations on ExcludedDistrict model"
      pattern: "prisma\\.excludedDistrict\\.(create|findMany|delete)"
    - from: "API routes"
      to: "src/lib/auth-utils.ts"
      via: "getCurrentUser() call in each route handler"
      pattern: "getCurrentUser\\(\\)"
---

<objective>
Implement the district management service layer and API routes for saving, excluding, and restoring districts.

Purpose: Provides the backend for users to manage their district territory — bookmarking districts of interest and excluding irrelevant ones with categorized reasons. All operations are scoped to the authenticated user.

Output: User resolution utility, 6 service functions, and 4 API route files (5 HTTP endpoints).
</objective>

<execution_context>
@/Users/dorenberge/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dorenberge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-discovery-district-profiles/03-01-SUMMARY.md

Key codebase references:
@src/services/district-service.ts (existing service — extend with 6 new functions)
@src/services/interfaces/district-service.ts (IDistrictService contract — all 6 methods defined)
@src/services/types/district.ts (SavedDistrict, ExcludedDistrict, ExclusionReason types)
@src/services/types/controlled-vocabulary.ts (EXCLUSION_CATEGORIES)
@src/services/types/common.ts (ServiceContext)
@prisma/schema.prisma (SavedDistrict + ExcludedDistrict models with @@unique([userId, districtId]))
@src/middleware.ts (Clerk auth pattern)
@src/lib/prisma.ts (Prisma singleton)
@src/app/api/districts/[districtId]/route.ts (existing API route pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user resolution utility</name>
  <files>src/lib/auth-utils.ts</files>
  <action>
Create `src/lib/auth-utils.ts` with a `getCurrentUser()` async function that:

1. Imports `auth` from `@clerk/nextjs/server` and `prisma` from `@/lib/prisma`
2. Calls `const { userId: clerkId } = await auth()` to get the Clerk user ID from the current request context
3. If no `clerkId`, throws an error with `code: 'UNAUTHENTICATED'`
4. Queries `prisma.user.findUnique({ where: { clerkId } })` to get the internal User record
5. If no user found, throws an error with `code: 'USER_NOT_FOUND'`
6. Returns the user object (at minimum: `{ id, tenantId, role }`)

Export the function as a named export. Return type should be `Promise<{ id: string; tenantId: string; role: string }>`.

This utility will be called from every district management API route to scope operations to the authenticated user. It is a server-only utility (uses Clerk's `auth()` which only works in server context).

Pattern reference: Follow the error-with-code pattern used in `district-service.ts` (e.g., `const error: any = new Error('...'); error.code = '...'; throw error;`).
  </action>
  <verify>Run `npx tsc --noEmit` — should compile without errors. Verify `src/lib/auth-utils.ts` exists and exports `getCurrentUser`.</verify>
  <done>getCurrentUser() resolves Clerk auth to internal User record with id/tenantId/role, throwing coded errors for unauthenticated or missing user scenarios.</done>
</task>

<task type="auto">
  <name>Task 2: Implement district management service functions and API routes</name>
  <files>
    src/services/district-service.ts
    src/app/api/districts/saved/route.ts
    src/app/api/districts/[districtId]/save/route.ts
    src/app/api/districts/[districtId]/exclude/route.ts
    src/app/api/districts/[districtId]/restore/route.ts
  </files>
  <action>
**Part A: Add 6 service functions to `src/services/district-service.ts`**

Add these imports at the top: `ExclusionReason`, `ExcludedDistrict` from `./types/district` (SavedDistrict is already importable). Add `EXCLUSION_CATEGORIES` from `./types/controlled-vocabulary`.

Implement these 6 functions matching the `IDistrictService` interface contract:

1. **`saveDistrict(userId: string, districtId: string): Promise<SavedDistrict>`**
   - Verify district exists via `prisma.district.findUnique`; throw `DISTRICT_NOT_FOUND` if missing
   - Create `prisma.savedDistrict.create({ data: { userId, districtId } })` with `include: { district: true }` to get district data
   - If unique constraint violation (P2002), the district is already saved — fetch and return existing
   - Map to `SavedDistrict` type: `{ districtId, name: district.name, location: district.location, enrollment: district.enrollment, savedAt: record.savedAt.toISOString() }`

2. **`getSavedDistricts(userId: string): Promise<SavedDistrict[]>`**
   - Query `prisma.savedDistrict.findMany({ where: { userId }, include: { district: true }, orderBy: { savedAt: 'desc' } })`
   - Map each to `SavedDistrict` type

3. **`removeSavedDistrict(userId: string, districtId: string): Promise<void>`**
   - Delete via `prisma.savedDistrict.delete({ where: { userId_districtId: { userId, districtId } } })`
   - Catch Prisma `P2025` (record not found) and throw error with `code: 'NOT_SAVED'`

4. **`excludeDistrict(userId: string, districtId: string, reason: ExclusionReason): Promise<ExcludedDistrict>`**
   - Validate `reason.category` is in `EXCLUSION_CATEGORIES`; throw `INVALID_CATEGORY` if not
   - Verify district exists; throw `DISTRICT_NOT_FOUND` if missing
   - Create `prisma.excludedDistrict.create(...)` with `userId, districtId, category: reason.category, note: reason.note`
   - If unique constraint violation (P2002), throw error with `code: 'ALREADY_EXCLUDED'`
   - Include district in create query for response mapping
   - Map to `ExcludedDistrict` type: `{ districtId, districtName: district.name, reason: { category, note }, excludedAt: record.excludedAt.toISOString() }`
   - Also remove from saved_districts if it was saved (cleanup: `prisma.savedDistrict.deleteMany({ where: { userId, districtId } })` — silent, no error if not saved)

5. **`getExcludedDistricts(userId: string): Promise<ExcludedDistrict[]>`**
   - Query `prisma.excludedDistrict.findMany({ where: { userId }, include: { district: true }, orderBy: { excludedAt: 'desc' } })`
   - Map each to `ExcludedDistrict` type

6. **`restoreDistrict(userId: string, districtId: string): Promise<void>`**
   - Delete via `prisma.excludedDistrict.delete({ where: { userId_districtId: { userId, districtId } } })`
   - Catch Prisma `P2025` and throw error with `code: 'NOT_EXCLUDED'`

Note: The interface defines `saveDistrict(districtId)` without userId, but the implementation needs userId. Accept userId as first param in the implementation — the API route will supply it from `getCurrentUser()`. This is consistent with the service-layer pattern where user context is resolved at the API boundary.

**Part B: Create 4 API route files (5 endpoints)**

Follow the existing API route pattern from `src/app/api/districts/[districtId]/route.ts`.

1. **`src/app/api/districts/saved/route.ts`** — `GET` handler
   - Call `getCurrentUser()` to get `user.id`
   - Call `getSavedDistricts(user.id)`
   - Return `NextResponse.json({ items: savedDistricts })`
   - Catch errors: `UNAUTHENTICATED` → 401, `USER_NOT_FOUND` → 401, default → 500

2. **`src/app/api/districts/[districtId]/save/route.ts`** — `POST` and `DELETE` handlers
   - POST: `getCurrentUser()` → `saveDistrict(user.id, districtId)` → return 200 with saved district
   - DELETE: `getCurrentUser()` → `removeSavedDistrict(user.id, districtId)` → return 200 with `{ success: true }`
   - Error mapping: `UNAUTHENTICATED/USER_NOT_FOUND` → 401, `DISTRICT_NOT_FOUND` → 404, `NOT_SAVED` → 404, default → 500

3. **`src/app/api/districts/[districtId]/exclude/route.ts`** — `POST` handler
   - Parse JSON body: `{ category: string, note?: string }`
   - Validate category is present; return 400 if missing
   - `getCurrentUser()` → `excludeDistrict(user.id, districtId, { category, note })` → return 200 with excluded district
   - Error mapping: `INVALID_CATEGORY` → 400, `DISTRICT_NOT_FOUND` → 404, `ALREADY_EXCLUDED` → 409, auth errors → 401, default → 500

4. **`src/app/api/districts/[districtId]/restore/route.ts`** — `POST` handler
   - `getCurrentUser()` → `restoreDistrict(user.id, districtId)` → return 200 with `{ success: true }`
   - Error mapping: `NOT_EXCLUDED` → 404, auth errors → 401, default → 500

All routes use Next.js 15 async params pattern: `const { districtId } = await params`.
  </action>
  <verify>
Run `npx tsc --noEmit` — should compile without errors.
Verify all 4 route files exist and export the correct HTTP methods:
- `src/app/api/districts/saved/route.ts` exports GET
- `src/app/api/districts/[districtId]/save/route.ts` exports POST, DELETE
- `src/app/api/districts/[districtId]/exclude/route.ts` exports POST
- `src/app/api/districts/[districtId]/restore/route.ts` exports POST
Verify `district-service.ts` exports all 6 new functions.
  </verify>
  <done>All 6 district management service functions implemented with Prisma queries, proper error codes, and type-safe return values. All 5 API endpoints created with auth resolution, input validation, and appropriate HTTP status codes.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — all new code compiles with TypeScript strict mode
2. `src/lib/auth-utils.ts` exists and exports `getCurrentUser`
3. `src/services/district-service.ts` exports all 10 functions (4 original + 6 new)
4. All 4 new API route files exist at correct paths
5. Each API route imports and uses `getCurrentUser()` for user resolution
6. Service functions handle Prisma error codes (P2002, P2025) with meaningful error codes
7. `excludeDistrict` validates category against `EXCLUSION_CATEGORIES`
8. `excludeDistrict` removes from saved_districts as cleanup
</verification>

<success_criteria>
- TypeScript compiles cleanly
- 6 new service functions match the IDistrictService interface contract
- 5 API endpoints properly resolve authenticated user and scope all operations
- Error codes map to appropriate HTTP status codes (401, 404, 409, 400, 500)
</success_criteria>

<output>
After completion, create `.planning/phases/04-district-management/04-01-SUMMARY.md`
</output>
